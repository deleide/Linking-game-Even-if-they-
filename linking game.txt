extends CenterContainer
# 导出变量，方便在编辑器中设置
@export var tile_texture: Texture2D
@export var tile_id: int = 0  # 用于标识图片类型

# 场景中的子节点
@onready var texture_rect = $TextureRect
@onready var button = $Button
@onready var highlight = $Highlight

var is_selected: bool = false

func _ready():
	# 设置图片
	if tile_texture:
		texture_rect.texture = tile_texture
	highlight.visible = false
	
	# 连接按钮信号
	button.pressed.connect(_on_button_pressed)

# 设置图片ID和纹理
func setup(id: int, texture: Texture2D):
	tile_id = id
	texture_rect.texture = texture

# 设置选中状态
func set_selected(selected: bool):
	is_selected = selected
	highlight.visible = selected

# 按钮点击处理
func _on_button_pressed():
	get_parent().get_parent().tile_clicked(self)

#场景结构：
CenterContainer (pictureTile.gd)
├── TextureRect (显示图片)
└── Button (覆盖整个格子，用于点击检测)
└──ColorRect(Highlight)


extends Node2D
# 导出变量
@export var grid_columns: int = 8
@export var grid_rows: int = 14

# 场景中的子节点
@onready var grid_container = $CanvasLayer/GridContainer
@onready var match_manager = $MatchManager

# 预加载图片资源
var tile_textures = [
	preload("res://恐龙图案/屏幕截图 2025-03-12 152048.png"),
	preload("res://恐龙图案/屏幕截图 2025-03-12 152914.png"),
	preload("res://恐龙图案/屏幕截图 2025-03-12 153243.png"),
	preload("res://恐龙图案/屏幕截图 2025-03-12 191109.png"),
	preload("res://恐龙图案/屏幕截图 2025-03-12 191258.png"),
	preload("res://恐龙图案/屏幕截图 2025-03-12 191544.png"),
	preload("res://恐龙图案/屏幕截图 2025-03-12 191717.png"),
	preload("res://恐龙图案/屏幕截图 2025-03-12 192156.png"),
	# 添加更多图片资源...
]

func _ready():
	# 初始化棋盘
	initialize_board()
	
	# 初始化匹配管理器
	match_manager.setup(grid_rows, grid_columns, grid_container)

# 处理格子点击
func tile_clicked(tile):
	match_manager.on_tile_clicked(tile)

# 初始化棋盘
func initialize_board():
	# 设置GridContainer属性
	grid_container.columns = grid_columns
	
	# 计算需要的图片对数量 (112个格子，需要56对不同的图片)
	var repeats = 14  # 每张图出现8次
	
	var pairs_needed = (grid_columns * grid_rows)/float(repeats)
	var available_textures = tile_textures.size()
	
	# 检查是否有足够的图片类型
	if available_textures < pairs_needed:
		push_error("Not enough tile textures! Need at least %d types." % pairs_needed)
		return
	
	# 创建图片ID列表 (每张图片出现8次)
	var tile_ids = []
	for i in range(pairs_needed):
		for j in range(repeats):
			tile_ids.append(i)
	
	# 随机打乱ID顺序
	tile_ids.shuffle()
	
	# 动态生成格子
	for i in range(grid_columns * grid_rows):
		# 加载格子场景
		var tile_scene = preload("res://pictureTile.tscn")
		var tile_instance = tile_scene.instantiate()
		
		# 设置格子属性
		var texture_index = tile_ids[i]
		tile_instance.setup(texture_index, tile_textures[texture_index])
		
		# 添加到GridContainer
		grid_container.add_child(tile_instance)
		
	# 确保GridContainer正确计算布局
	await get_tree().process_frame
	grid_container.queue_sort()

# 清空棋盘
func clear_board():
	for child in grid_container.get_children():
		child.queue_free()
#场景结构：
Node2D (MainGame.gd)
└──CanvasLayer
        └── GridContainer
└──Node(MatchManager)

extends Node
class_name MatchManager

# 存储当前选中的格子
var selected_tile = null
# 存储棋盘上所有格子的引用
var tile_grid = []
# 存储棋盘的行列数
var grid_rows: int
var grid_columns: int

# 初始化函数
func setup(rows: int, columns: int, grid_container: GridContainer):
	grid_rows = rows
	grid_columns = columns
	
	# 初始化二维数组
	tile_grid = []
	for y in range(grid_rows):
		tile_grid.append([])
		for x in range(grid_columns):
			tile_grid[y].append(null)
	
	# 填充二维数组
	var index = 0
	for child in grid_container.get_children():
		var x = index % grid_columns
		@warning_ignore("integer_division")
		var y = index / grid_columns
		tile_grid[y][x] = child
		index += 1

# 处理格子点击
func on_tile_clicked(tile):
	# 如果已经选中了一个格子
	if selected_tile != null:
		# 如果点击的是同一个格子，取消选择
		if selected_tile == tile:
			selected_tile.set_selected(false)
			selected_tile = null
			return
		
		# 检查是否可以消除
		if check_match(selected_tile, tile):
			# 消除格子
			remove_tiles(selected_tile, tile)
		else:
			# 不能消除，取消前一个选中的格子
			selected_tile.set_selected(false)
		
		# 无论是否匹配，都取消前一个选中的格子
		selected_tile = null
	else:
		# 没有选中的格子，选中当前点击的格子
		selected_tile = tile
		tile.set_selected(true)

# 检查两个格子是否匹配
func check_match(tile1, tile2) -> bool:
	# 如果ID不同，不匹配
	if tile1.tile_id != tile2.tile_id:
		return false
	
	# 获取两个格子的位置
	var pos1 = get_tile_position(tile1)
	var pos2 = get_tile_position(tile2)
	
	# 检查是否可以连接
	return can_connect(pos1, pos2)

# 获取格子在网格中的位置
func get_tile_position(tile) -> Vector2:
	for y in range(grid_rows):
		for x in range(grid_columns):
			if tile_grid[y][x] == tile:
				return Vector2(x, y)
	return Vector2(-1, -1)

# 检查两个位置是否可以连接
func can_connect(pos1: Vector2, pos2: Vector2) -> bool:
	# 如果是同一个位置，不能连接
	if pos1 == pos2:
		return false
	
	# 检查直线连接
	if check_straight_line(pos1, pos2):
		return true
	
	# 检查一次拐弯连接
	if check_one_corner(pos1, pos2):
		return true
	
	# 检查两次拐弯连接
	if check_two_corners(pos1, pos2):
		return true
	
	return false

# 检查直线连接
func check_straight_line(pos1: Vector2, pos2: Vector2) -> bool:
	# 水平直线
	if pos1.y == pos2.y:
		var start_x = min(pos1.x, pos2.x)
		var end_x = max(pos1.x, pos2.x)
		
		for x in range(start_x + 1, end_x):
			if tile_grid[pos1.y][x] != null:
				return false
		return true
	
	# 垂直直线
	if pos1.x == pos2.x:
		var start_y = min(pos1.y, pos2.y)
		var end_y = max(pos1.y, pos2.y)
		
		for y in range(start_y + 1, end_y):
			if tile_grid[y][pos1.x] != null:
				return false
		return true
	
	return false

# 检查一次拐弯连接
func check_one_corner(pos1: Vector2, pos2: Vector2) -> bool:
	# 检查拐点1 (pos1.x, pos2.y)
	var corner1 = Vector2(pos1.x, pos2.y)
	if tile_grid[corner1.y][corner1.x] == null:
		if check_straight_line(pos1, corner1) and check_straight_line(corner1, pos2):
			return true
	
	# 检查拐点2 (pos2.x, pos1.y)
	var corner2 = Vector2(pos2.x, pos1.y)
	if tile_grid[corner2.y][corner2.x] == null:
		if check_straight_line(pos1, corner2) and check_straight_line(corner2, pos2):
			return true
	
	return false

# 检查两次拐弯连接
func check_two_corners(pos1: Vector2, pos2: Vector2) -> bool:
	# 检查水平方向的两拐弯路径
	for x in range(grid_columns):
		if x == pos1.x or x == pos2.x:
			continue
			
		var corner1 = Vector2(x, pos1.y)
		var corner2 = Vector2(x, pos2.y)
		
		if tile_grid[corner1.y][corner1.x] == null and tile_grid[corner2.y][corner2.x] == null:
			if check_straight_line(pos1, corner1) and check_straight_line(corner1, corner2) and check_straight_line(corner2, pos2):
				return true
	
	# 检查垂直方向的两拐弯路径
	for y in range(grid_rows):
		if y == pos1.y or y == pos2.y:
			continue
			
		var corner1 = Vector2(pos1.x, y)
		var corner2 = Vector2(pos2.x, y)
		
		if tile_grid[corner1.y][corner1.x] == null and tile_grid[corner2.y][corner2.x] == null:
			if check_straight_line(pos1, corner1) and check_straight_line(corner1, corner2) and check_straight_line(corner2, pos2):
				return true
	
	return false

# 移除匹配的格子
func remove_tiles(tile1, tile2):
	var pos1 = get_tile_position(tile1)
	var pos2 = get_tile_position(tile2)
	
	# 从网格中移除
	tile_grid[pos1.y][pos1.x] = null
	tile_grid[pos2.y][pos2.x] = null
	
	# 从场景中移除
	tile1.queue_free()
	tile2.queue_free()
